# 프로세스

#### 고아 프로세스

- 프로세스의 종료 처리를 부모 프로세스가 해줘야 하는데 부모 프로세스가 먼저 종료되어 자식 프로세스의 종료 처리를 하지 못할 때 자식 프로세스는 고아 프로세스가 된다.

- 이 프로세스의 종료 처리는 init 프로세스가 하게 된다.

#### 좀비 프로세스

- 이미 종료된 프로세스가 리소스를 반환하지 못한 상태로 남아있는 경우 좀비 프로세스라고 한다.

- 서버를 재시작하는 해결방법이 있다.(이게 해결?)

- 이전에 공부를 할 때에도 의문이 들었던 점인데 좀비 프로세스는 **_자식 프로세스가 부모 프로세스보다 먼저 종료되었을 때_**라고 하는데 이건 그냥 당연한 상황이 아닌가?

- **_좀비 프로세스가 생기는 원인을 조금 더 풀어서 설명하면 프로세스가 종료될 때 부모 프로세스가 종료 처리를 하면서 리소스를 회수 해야 하는데 부모 프로세스가 그 종료 처리를 하지 않았기 때문이다. 좀비 프로세스는 종료된 상태이지만 운영체제가 관리하는 프로세스 테이블에 남아서 리소스를 차지하고 있는 상태이다._**

- **_아래 내용 포함해서 원인은 부모 프로세스가 wait() 시스템 콜 호출하면서 SIGCHLD를 받아 자식 프로세스의 종료 처리를 하지 않아서 생기는 것 좀비 프로세스는 이미 스스로 exit()는 한 상태_**

- 찾아보니 `wait()` 시스템 콜의 역할이 단순히 자식 프로세스의 종료를 기다리는 것이 아니라 종료 처리의 역할도 한다는 것 같다.

- 커널은 자식 프로세스의 종료 *상태*를 가지고 있고 `wait()` 시스템 콜은 그 종료 상태를 회수하고 그 때 자식 프로세스는 리소스를 반환하고 완전히 종료되는 것이다.

- 그렇다면 좀비 프로세스가 생기는 이유는 부모 프로세스가 자식 프로세스의 종료 처리를 위한 `wait()` 시스템 콜을 호출하지 않고 자식 프로세스가 종료된 이후에도 부모 프로세스는 계속 동작하는 경우에 생긴다고 볼 수 있다. (예시 코드는 있지만 실제로 어떤 상황에서 벌어지는지, 실제 응용 프로그램이 동작하면서 어떤 경우에 이런 상황이 생기는지 이해가 잘 되지 않는다. 그래도 일단 이유를 한가지 알았고 해결 방법을 하나 알았으니 넘어가자.)

- 그럼 SIGCHLD는...?

- `wait()`를 사용했을 때 부모 프로세스는 SIGCHLD를 받고 자식 프로세스를 종료하라는 명령을 수행하는데 이 때 종료할 자식 프로세스가 없으면 블로킹 상태에 놓인다.

- 그럼 결국 `wait()`도 부모 프로세스에게 SIGCHLD를 보내도록 하는 것, 좀비 프로세스의 해결 방법은 좀비 프로세스의 부모 프로세스를 찾고 부모 프로세스에게 SIGCHLD를 보내면 해결할 수 있다.
