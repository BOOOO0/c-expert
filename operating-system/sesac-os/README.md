# 프로세스

#### 고아 프로세스

- 프로세스의 종료 처리를 부모 프로세스가 해줘야 하는데 부모 프로세스가 먼저 종료되어 자식 프로세스의 종료 처리를 하지 못할 때 자식 프로세스는 고아 프로세스가 된다.

- 이 프로세스의 종료 처리는 init 프로세스가 하게 된다.

#### 좀비 프로세스

- 이미 종료된 프로세스가 리소스를 반환하지 못한 상태로 남아있는 경우 좀비 프로세스라고 한다.

- 서버를 재시작하는 해결방법이 있다.(이게 해결?)

- 이전에 공부를 할 때에도 의문이 들었던 점인데 좀비 프로세스는 ***자식 프로세스가 부모 프로세스보다 먼저 종료되었을 때***라고 하는데 이건 그냥 당연한 상황이 아닌가?

- 찾아보니 `wait()` 시스템 콜의 역할이 단순히 자식 프로세스의 종료를 기다리는 것이 아니라 종료 처리의 역할도 한다는 것 같다.

- 커널은 자식 프로세스의 종료 *상태*를 가지고 있고 `wait()` 시스템 콜은 그 종료 상태를 회수하고 그 때 자식 프로세스는 리소스를 반환하고 완전히 종료되는 것이다.

- 그렇다면 좀비 프로세스가 생기는 이유는 부모 프로세스가 자식 프로세스의 종료 처리를 위한 `wait()` 시스템 콜을 호출하지 않고 자식 프로세스가 종료된 이후에도 부모 프로세스는 계속 동작하는 경우에 생긴다고 볼 수 있다. (예시 코드는 있지만 실제로 어떤 상황에서 벌어지는지, 실제 응용 프로그램이 동작하면서 어떤 경우에 이런 상황이 생기는지 이해가 잘 되지 않는다. 그래도 일단 이유를 한가지 알았고 해결 방법을 하나 알았으니 넘어가자.)

- 그럼 SIGCHLD는...?

- `wait()`를 사용했을 때 부모 프로세스는 SIGCHLD를 받고 자식 프로세스를 종료하라는 명령을 수행하는데 이 때 종료할 자식 프로세스가 없으면 블로킹 상태에 놓인다.

- 그럼 결국 `wait()`도 부모 프로세스에게 SIGCHLD를 보내도록 하는 것, 좀비 프로세스의 해결 방법은 좀비 프로세스의 부모 프로세스를 찾고 부모 프로세스에게 SIGCHLD를 보내면 해결할 수 있다.

### SIGNAL

- 